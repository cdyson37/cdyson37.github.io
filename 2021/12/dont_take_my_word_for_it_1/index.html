<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=generator content="Hugo 0.88.1">
<title>Don't Take My Word For It (Part 1): Getting the type dynamically - charliedyson.net</title>
<meta name=description content="Using typeid to determine an object&rsquo;s type at runtime.">
<link rel=stylesheet href=/css/ui.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">
</head>
<body>
<header class="container no-print">
<div class=u-header>
<nav class=bar>
<ul><li>
<a href=/>
<img class=icon-text src=/img/prev.svg>
</a>
</li></ul>
</nav>
</div>
</header>
<main class=container>
<article>
<header><hgroup id=brand>
<h1>Don't Take My Word For It (Part 1): Getting the type dynamically</h1>
<h5>
<time datetime="2021-12-25 00:00:00 +0000 UTC">25 Dec 2021</time>
<span class=no-print>
<span>
</h5>
</hgroup>
<hr class=sep>
</header>
<p>Ever wanted to know what type something is in C++, but your editor can&rsquo;t or won&rsquo;t tell you (or you don&rsquo;t trust it&mldr;?) You&rsquo;ve probably been in some templated function, nested a few levels deep, gone to get a coffee, come back and forgotten quite how it fits together and asked yourself &ldquo;what exactly is T anyway&rdquo;? Don&rsquo;t take my word or anyone else&rsquo;s - If in doubt, ask the compiler (or the runtime).</p>
<p>In Python we&rsquo;re used to doing simply</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#f92672>&gt;&gt;&gt;</span> type(<span style=color:#e6db74>&#34;foo&#34;</span>)
<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#a6e22e>str</span><span style=color:#e6db74>&#39;&gt;</span>
</code></pre></div><p>Types are objects. <code>type(some_object)</code> returns an object that happens to be the type of <code>some_object</code>. Since that type is itself an object, you can print it. Informative and helpful.</p>
<p>No such luck in C++: types are not objects. If you try to do <code>std::cout &lt;&lt; std::string</code> you&rsquo;ll get an angry compiler (<code>std::string</code> is not an object, it&rsquo;s a type, so you can&rsquo;t just pass it to some overload of <code>operator&lt;&lt;</code>).</p>
<p>A bit of Googling later, you might come across the <code>typeid</code> operator which returns a <code>std::type_info</code> object, which as a <code>name()</code> function. So far this appears pretty helpful. Giving it a test drive&mldr;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;typeinfo&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> c_string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foo&#34;</span>;
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> cpp_string <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>string (<span style=color:#e6db74>&#34;foo&#34;</span>);

  <span style=color:#75715e>// What&#39;s the type of c_string?
</span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>typeid</span>(c_string).name() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;

  <span style=color:#75715e>// What&#39;s the type of cpp_string?
</span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>typeid</span>(cpp_string).name() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
}
</code></pre></div><p>Possible output (<a href=https://godbolt.org/z/9sPo4zW75>compiler explorer</a>) if you use gcc:</p>
<pre tabindex=0><code>PKc
NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
</code></pre><p>There&rsquo;s something there, but you wouldn&rsquo;t call it easy to read! And we&rsquo;re already firmly into implementation-defined behaviour. You&rsquo;ll get something else that might be more-or-less readable. At least the second bit at least has the word &ldquo;string&rdquo; in it.</p>
<p>Fortunately for gcc users you can demangle this (yes that&rsquo;s a technical term) with a command-line tool:</p>
<pre tabindex=0><code>$ c++filt -t PKc
char const*
$ c++filt -t NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;
</code></pre><p>With gcc it&rsquo;s also possible to do this on the fly in C++ (see a nice SO answer <a href=https://stackoverflow.com/questions/281818/unmangling-the-result-of-stdtype-infoname>here</a>), but this is strictly vendor-specific.</p>
<p>So we&rsquo;ve got something that works, on one compiler at least, and with a little bit of effort prints out the type of a variable. Well, not quite&mldr; <code>typeid</code> actually gives you the type of an expression. It doesn&rsquo;t have the special fudge <code>decltype</code> has, wherein <code>decltype(x)</code> means &ldquo;the type of x&rdquo; and anything that isn&rsquo;t just a variable name, <code>decltype((x))</code>, meaning &ldquo;the type of the expression&rdquo;. In our specific case, the type of <code>cpp_string</code> should be <em>const</em> but <code>typeid</code> loses the top-level qualifier for us.</p>
<p>I&rsquo;m a stranger to the Windows programming world, but I downloaded Visual Studio Community 2022 and ran the same program - here&rsquo;s the output:</p>
<pre tabindex=0><code>char const * __ptr64
class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;
</code></pre><p>Actually quite helpful! It still loses the top-level const on the string (that&rsquo;s inevitable because that&rsquo;s how <code>typeid</code> works) but at least it doesn&rsquo;t need decoding.</p>
<p>There&rsquo;s another use for <code>typeid</code> that we haven&rsquo;t covered here but deserves a mention: it can be used for RTTI purposes. If you&rsquo;ve got a base class <code>Base</code> and one or more derived classes (and you&rsquo;ve remembered your virtual destructor in the base class), <code>typeid</code> can tell you which derived class a reference-to-base refers to:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;typeinfo&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Base</span>
{
  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>Base() {};
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>D1</span> <span style=color:#f92672>:</span> Base {};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>D2</span> <span style=color:#f92672>:</span> Base {};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
  D2 derived;
  Base <span style=color:#f92672>&amp;</span>ptr_to_base <span style=color:#f92672>=</span> derived;

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>boolalpha;
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#66d9ef>typeid</span> (ptr_to_base) <span style=color:#f92672>==</span> <span style=color:#66d9ef>typeid</span> (D1)) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#66d9ef>typeid</span> (ptr_to_base) <span style=color:#f92672>==</span> <span style=color:#66d9ef>typeid</span> (D2)) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
}
</code></pre></div><p>Output (<a href=https://godbolt.org/z/bPrc9Moec>compiler explorer</a>):</p>
<pre tabindex=0><code>false
true
</code></pre><p>So far we&rsquo;ve looked at the uses of <code>typeid</code>. In <a href=https://charliedyson.net/2021/12/dont_take_my_word_for_it_2/>Part 2</a> we will use a trick to work out mystery types using compiler error messages.</p>
</article>
<nav class="no-print post-nav">
<a class=next-post href=https://charliedyson.net/2021/12/dont_take_my_word_for_it_2/>Don't Take My Word For It (Part 2): Tricking the compiler<img class=icon-text src=/img/next.svg>
</a>
</nav>
<hr class=sep>
</main>
<footer class="container no-print">
<div class=u-footer>
<a href=mailto:charlie@charliedyson.net><img class=icon-social src=/img/email.svg alt="Email Me!"></a>
<a href=https://github.com/cdyson37><img class=icon-social src=/img/github.svg alt=Github></a>
<a href=https://www.linkedin.com/in/charlie-dyson-a701a31a5><svg width="30" height="30" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg"><path d="M1e2.0C45 0 0 45 0 1e2V9e2c0 55 45 1e2 1e2 1e2H9e2c55 0 1e2-45 1e2-1e2V1e2C1e3 45 955 0 9e2.0H1e2s0 0 0 0m0 75s8e2.0 8e2.0c14 0 25 11 25 25V9e2c0 14-11 25-25 25H1e2c-14 0-25-11-25-25V1e2c0-14 11-25 25-25M336 332s0 457 0 457-125 0-125 0 0-457 0-457 125 0 125 0m10-126s0 0 0 0c0 41-33 74-73 74s-72-33-72-74c0-40 32-73 72-73s73 33 73 73M834 508s0 281 0 281-125 0-125 0 0-233 0-233c0-140-166-129-166 0V789s-124 0-124 0 0-457 0-457 124 0 124 0 0 74 0 74c58-108 291-116 291 102"/></svg></a>
<a href=https://charliedyson.net/index.xml target=_blank><img class=icon-social src=/img/feed.svg alt=Feed></a>
<p>
Theme used: <a href=https://github.com/yursan9/manis-hugo-theme>Manis</a><br>
</p>
<a href=#brand>
<img class=icon-text src=/img/toup.svg alt="To Up">
<span>Back to Up</span>
</a>
</div>
</footer>
</body>
</html>