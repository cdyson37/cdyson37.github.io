<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=generator content="Hugo 0.88.1">
<title>Don't Take My Word For It (Part 3): A handy reference table - charliedyson.net</title>
<meta name=description content="How are template arguments to a function deduced? We will generate a helpful reference table.">
<link rel=stylesheet href=/css/ui.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">
</head>
<body>
<header class="container no-print">
<div class=u-header>
<nav class=bar>
<ul><li>
<a href=/>
<img class=icon-text src=/img/prev.svg>
</a>
</li></ul>
</nav>
</div>
</header>
<main class=container>
<article>
<header><hgroup id=brand>
<h1>Don't Take My Word For It (Part 3): A handy reference table</h1>
<h5>
<time datetime="2021-12-27 00:00:00 +0000 UTC">27 Dec 2021</time>
<span class=no-print>
<span>
</h5>
</hgroup>
<hr class=sep>
</header>
<p>In <a href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_1/>Part 1</a> we looked at the <code>typeid</code> operator and in <a href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_2/>Part 2</a> we used a little cheat to work out mystery types using compiler error messages.</p>
<p>Let&rsquo;s take this a bit further and try to answer a general question: if I call some function template <code>f(T x)</code>, <code>f(T& x)</code>, <code>f(T&& x)</code> (or <code>const</code> versions of any of those) with an <code>int</code>, <code>int&</code> or <code>int&&</code> (or <code>const</code> versions of any of those), to what does <code>T</code> deduce? And what&rsquo;s the resulting type of <code>x</code>?</p>
<p>That&rsquo;s 36 possible combinations in each of two tables (one for <code>T</code> and one for <code>x</code>). We can work them out on an individual basis with the technique from Part 2. For example if we wanted to know what happens if we call <code>f(T&& x)</code> and <code>x</code> is <code>int&&</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;utility&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Incomplete</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> f(T<span style=color:#f92672>&amp;&amp;</span> x)
{
    (<span style=color:#66d9ef>void</span>) x; <span style=color:#75715e>// suppress compiler warning
</span><span style=color:#75715e></span>    Incomplete<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span> (x)<span style=color:#f92672>&gt;</span> incomplete;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
    <span style=color:#66d9ef>int</span> some_int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    f(std<span style=color:#f92672>::</span>move (some_int));
}
</code></pre></div><p>Output (if you&rsquo;ve got a friendly-ish compiler):</p>
<pre tabindex=0><code>prog.cc: In instantiation of 'void f(T&amp;&amp;) [with T = int]':
prog.cc:16:6:   required from here
prog.cc:10:30: error: 'Incomplete&lt;int&amp;&amp;&gt; incomplete' has incomplete type
   10 |     Incomplete&lt;decltype (x)&gt; incomplete;
      |                              ^~~~~~~~~~
</code></pre><p>The compiler tells us two things here, courtesy of the helpful error message:</p>
<ul>
<li><code>T</code> is <code>int</code>, and</li>
<li><code>x</code> is <code>int&&</code>.</li>
</ul>
<p>This is exactly what we&rsquo;d hope to see - <code>f()</code> gets an rvalue reference to a moved-from variable.</p>
<p>One case down then, but there are 35 to go to fill out our 6x6 tables. Let&rsquo;s try to do them all in one go!</p>
<p>Firstly, let&rsquo;s encode the possible outcome types as strings. We know it can only be <code>int</code>, <code>int&</code> etc. so there aren&rsquo;t too many:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> TypeName;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;int&#34;</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&gt;</span>[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;int&amp;&#34;</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&amp;&gt;</span>[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;int&amp;&amp;&#34;</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;const int&#34;</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&gt;</span>[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;const int&amp;&#34;</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&amp;&gt;</span>[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;const int&amp;&amp;&#34;</span>;
</code></pre></div><p>These are <a href=https://en.cppreference.com/w/cpp/language/variable_template>variable templates</a> introduced in C++14. So <code>TypeName&lt;int></code> will just give us a C-string of <code>"int"</code>. If we&rsquo;ve missed out a <code>TypeName</code> specialisation, we will get a compiler error as the base template for <code>TypeName</code> is not initialised.</p>
<p>Next up, for convenience&rsquo;s sake we make a little pair type to store the deduced <code>T</code> and the type of <code>x</code> in each case. We could work out <code>x</code> ourselves but again, let&rsquo;s make the compiler do the work and reduce the risk of a mistake. The name of the struct will make sense in a moment:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span> U<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ReturnedType</span>
{
  <span style=color:#66d9ef>using</span> deduced_template_argument <span style=color:#f92672>=</span> T; <span style=color:#75715e>// type T
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>using</span> argument_type <span style=color:#f92672>=</span> U;             <span style=color:#75715e>// type of x
</span><span style=color:#75715e></span>};
</code></pre></div><p>So - we want to try out e.g. <code>template &lt;typename T> f(T x)</code> with <code>x</code> as <code>int</code>, <code>int&</code> etc. But it&rsquo;s hard to talk about <code>f</code> since it&rsquo;s a template and not a function. We can&rsquo;t just take its address or use it as an argument to a template without first selecting a <code>T</code>, which totally undermines what we&rsquo;re trying to do since we&rsquo;re trying to find out what <code>T</code> would deduce to!</p>
<p>The solution is to wrap our <code>f</code> in something that we can give a name to:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CalledByValue</span>
{
  <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
  <span style=color:#66d9ef>static</span>
  <span style=color:#66d9ef>auto</span> f (T x) <span style=color:#f92672>-&gt;</span> ReturnedType<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>decltype</span> (x)<span style=color:#f92672>&gt;</span>;
};
</code></pre></div><p><code>CalledByValue</code> is an ordinary struct, not a template, and we can use it as a template argument. Rather than make the inner <code>f</code> just return void, we&rsquo;ve used our <code>ReturnedType</code> to encode both <code>T</code> and the type of <code>x</code>. We never actually call <code>f</code> (we&rsquo;re just going to ask the compiler what type it would return), so there&rsquo;s no need to actually provide a definition for the function.</p>
<p>Next we also define <code>CalledByReference</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CalledByReference</span>
{
  <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
  <span style=color:#66d9ef>static</span>
  <span style=color:#66d9ef>auto</span> f (T<span style=color:#f92672>&amp;</span> x) <span style=color:#f92672>-&gt;</span> ReturnedType<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>decltype</span> (x)<span style=color:#f92672>&gt;</span>;
};
</code></pre></div><p>i.e. exactly the same but with an extra <code>&</code>. Similarly we then define <code>CalledByForwardingReference</code> (takes <code>T&&</code>), <code>CalledByConstValue</code> (takes <code>const T</code>), <code>CalledByConstReference</code> (takes <code>const T&</code>), <code>CalledByConstForwardingReference</code> (takes <code>const T&&</code> - we wills see below that this is a bit of a misnomer).</p>
<p>We&rsquo;re almost there. We just need a little helper that takes e.g. <code>CalledByValue</code> and <code>int&</code> as template arguments and returns either a string of type <code>T</code> or a string of the type of <code>x</code>. Firstly we&rsquo;ll define an enum to choose which of those two things we want in our table:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TableType</span>
{
  DEDUCED_TEMPLATE_ARGUMENT,
  ARGUMENT_TYPE
};
</code></pre></div><p>Our function is then</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>TableType table_type, <span style=color:#66d9ef>typename</span> Target, <span style=color:#66d9ef>typename</span> Arg<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>auto</span> get_type_name ()
{

  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>requires</span> {Target<span style=color:#f92672>::</span>f (std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>Arg<span style=color:#f92672>&gt;</span> ());})
  {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;-&#34;</span>;
  }
  <span style=color:#66d9ef>else</span>
  {
    <span style=color:#66d9ef>using</span> Result <span style=color:#f92672>=</span> <span style=color:#66d9ef>decltype</span> (Target<span style=color:#f92672>::</span>f (std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>Arg<span style=color:#f92672>&gt;</span> ()));

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (table_type <span style=color:#f92672>==</span> TableType<span style=color:#f92672>::</span>ARGUMENT_TYPE)
    {
      <span style=color:#66d9ef>return</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Result<span style=color:#f92672>::</span>argument_type<span style=color:#f92672>&gt;</span>;
    }
    <span style=color:#66d9ef>else</span>
    {
      <span style=color:#66d9ef>return</span> TypeName<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Result<span style=color:#f92672>::</span>deduced_template_argument<span style=color:#f92672>&gt;</span>;
    }
  }
}
</code></pre></div><p>So <code>Target</code> will be something like <code>CalledByValue</code> and <code>Arg</code> will be something like <code>int&</code>.</p>
<p>Our first <code>if</code> just returns a <code>"-"</code> if it&rsquo;s impossible to call <code>Target::f</code> with an argument of type <code>Arg</code>. The <code>requires</code> keyword gives us a bool that can be used in a <code>constexpr</code> context. &ldquo;if constexpr requires&rdquo; doesn&rsquo;t sound terribly grammatical to me, but it gets the job done.</p>
<p>You might be tempted instead to just try <code>if constexpr (!std::is_invocable&lt;decltype (Target::f), Arg> ())</code>, but that won&rsquo;t work because <code>Target::f</code> doesn&rsquo;t have a type - it&rsquo;s a template! If we don&rsquo;t have C++20 and <code>requires</code> to hand then the problem can be solved with some <a href=https://en.cppreference.com/w/cpp/types/void_t>void_t</a> trickery.</p>
<p>Once we&rsquo;re past that first <code>if constexpr</code> the rest falls into place nicely. We know it&rsquo;s safe to do the <code>decltype</code> because we&rsquo;ve established that <code>Target::f</code> really can be called with an <code>Arg</code>. We know <code>Result</code> is then <code>ReturnedType&lt;T, decltype(x)></code> (because that&rsquo;s what all the <code>f</code>s return) so it&rsquo;s then a matter of extracting one of those two things from <code>ReturnedType</code> and converting that to a string with <code>TypeName</code>.</p>
<p>The rest of the program is just handle-turning. We could try to be clever and iterate through the various types with variadics but I think that just makes it harder to read.</p>
<p>First, a function to make to make a single table row. Here <code>table_type</code> specifies whether we want <code>T</code> or <code>decltype(x)</code> and <code>Target</code> as before might be <code>CalledByValue</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>TableType table_type, <span style=color:#66d9ef>typename</span> Target<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> make_table_row ()
{
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> get_type_name<span style=color:#f92672>&lt;</span>table_type, Target, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> () <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;|&#39;</span>
            <span style=color:#f92672>&lt;&lt;</span> get_type_name<span style=color:#f92672>&lt;</span>table_type, Target, <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&gt;</span> () <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;|&#39;</span>
            <span style=color:#f92672>&lt;&lt;</span> get_type_name<span style=color:#f92672>&lt;</span>table_type, Target, <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&amp;&gt;</span> () <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;|&#39;</span>
            <span style=color:#f92672>&lt;&lt;</span> get_type_name<span style=color:#f92672>&lt;</span>table_type, Target, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> () <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;|&#39;</span>
            <span style=color:#f92672>&lt;&lt;</span> get_type_name<span style=color:#f92672>&lt;</span>table_type, Target, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&gt;</span> () <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;|&#39;</span>
            <span style=color:#f92672>&lt;&lt;</span> get_type_name<span style=color:#f92672>&lt;</span>table_type, Target, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&amp;&gt;</span> () <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
}
</code></pre></div><p>We use the pipe symbol as a delimiter so we can easily put this into a Markdown table.</p>
<p>Making a whole table just means calling this once per row, with a header at the top:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>TableType table_type<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> make_table ()
{
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;||int|int&amp;|int&amp;&amp;|const int|const int &amp;|const int &amp;&amp;|</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|-|-|-|-|-|-|-|</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|f(T x)|&#34;</span>;
  make_table_row<span style=color:#f92672>&lt;</span>table_type, CalledByValue<span style=color:#f92672>&gt;</span> ();

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|f(const T x)|&#34;</span>;
  make_table_row<span style=color:#f92672>&lt;</span>table_type, CalledByConstValue<span style=color:#f92672>&gt;</span> ();

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|f(T&amp; x)|&#34;</span>;
  make_table_row<span style=color:#f92672>&lt;</span>table_type, CalledByReference<span style=color:#f92672>&gt;</span> ();

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|f(const T&amp; x)|&#34;</span>;
  make_table_row<span style=color:#f92672>&lt;</span>table_type, CalledByConstReference<span style=color:#f92672>&gt;</span> ();

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|f(const T&amp;&amp; x)|&#34;</span>;
  make_table_row<span style=color:#f92672>&lt;</span>table_type, CalledByConstForwardingReference<span style=color:#f92672>&gt;</span> ();

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;|f(T&amp;&amp; x)|&#34;</span>;
  make_table_row<span style=color:#f92672>&lt;</span>table_type, CalledByForwardingReference<span style=color:#f92672>&gt;</span> ();
}
</code></pre></div><p>Finally <code>main()</code> just makes the two types of table:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;T deduces as ... when called with:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
  make_table<span style=color:#f92672>&lt;</span>TableType<span style=color:#f92672>::</span>DEDUCED_TEMPLATE_ARGUMENT<span style=color:#f92672>&gt;</span> ();

  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;decltype(x) is ... when called with:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
  make_table<span style=color:#f92672>&lt;</span>TableType<span style=color:#f92672>::</span>ARGUMENT_TYPE<span style=color:#f92672>&gt;</span> ();
}
</code></pre></div><p>Phew. Here&rsquo;s the complete program on <a href=https://godbolt.org/z/dv8czvMzq>compiler explorer</a>. Now let&rsquo;s look at the two tables:</p>
<p><strong>T deduces as &mldr; when called with:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>int</th>
<th>int&</th>
<th>int&&</th>
<th>const int</th>
<th>const int &</th>
<th>const int &&</th>
</tr>
</thead>
<tbody>
<tr>
<td>f(T x)</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>f(const T x)</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>f(T& x)</td>
<td>-</td>
<td>int</td>
<td>-</td>
<td>const int</td>
<td>const int</td>
<td>const int</td>
</tr>
<tr>
<td>f(const T& x)</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>f(const T&& x)</td>
<td>int</td>
<td>-</td>
<td>int</td>
<td>int</td>
<td>-</td>
<td>int</td>
</tr>
<tr>
<td>f(T&& x)</td>
<td>int</td>
<td>int&</td>
<td>int</td>
<td>const int</td>
<td>const int&</td>
<td>const int</td>
</tr>
</tbody>
</table>
<p><strong>decltype(x) is &mldr; when called with:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>int</th>
<th>int&</th>
<th>int&&</th>
<th>const int</th>
<th>const int &</th>
<th>const int &&</th>
</tr>
</thead>
<tbody>
<tr>
<td>f(T x)</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>f(const T x)</td>
<td>const int</td>
<td>const int</td>
<td>const int</td>
<td>const int</td>
<td>const int</td>
<td>const int</td>
</tr>
<tr>
<td>f(T& x)</td>
<td>-</td>
<td>int&</td>
<td>-</td>
<td>const int&</td>
<td>const int&</td>
<td>const int&</td>
</tr>
<tr>
<td>f(const T& x)</td>
<td>const int&</td>
<td>const int&</td>
<td>const int&</td>
<td>const int&</td>
<td>const int&</td>
<td>const int&</td>
</tr>
<tr>
<td>f(const T&& x)</td>
<td>const int&&</td>
<td>-</td>
<td>const int&&</td>
<td>const int&&</td>
<td>-</td>
<td>const int&&</td>
</tr>
<tr>
<td>f(T&& x)</td>
<td>int&&</td>
<td>int&</td>
<td>int&&</td>
<td>const int&&</td>
<td>const int&</td>
<td>const int&&</td>
</tr>
</tbody>
</table>
<p>To pick an example, if we have <code>f(T&& x)</code> and we call it with a <code>const int</code>, then <code>T</code> will be <code>const int</code> (first table) and <code>x</code> will have type <code>const int&&</code> (second table). The &ldquo;-&ldquo;s represent arguments that can&rsquo;t be used for a particular function - you&rsquo;d get a compiler error.</p>
<p>The table seems to be consistent with a few half-remembered rules of thumb:</p>
<ul>
<li><code>T</code> never deduces as a reference, unless you&rsquo;re in the <code>f(T&&)</code> magic case.</li>
<li>With <code>f(const T x)</code>, the <code>const</code> makes no difference at all to the deduction of <code>T</code>, it&rsquo;s just to prevent us from changing <code>x</code> in the function.</li>
<li>With <code>f(T& x)</code>, <code>T</code> deduces as <code>const</code> whenever it&rsquo;s needed.</li>
<li><code>f(T x)</code> and <code>f(const T& x)</code> always work, no matter what you call them with. In latter case, it will extend a reference to a temporary if necessary.</li>
<li><code>f(T&& x)</code> always works and will always give you some kind of (possibly const, possibly rvalue) reference.</li>
</ul>
<p>Another thing to note is that the column for <code>int</code> is identical to the column for <code>int&&</code>. This makes sense as we never care what sort of rvalue <code>f()</code> is being called with: <code>f(42)</code> (i.e. with <code>int</code>, a prvalue) and <code>f(std::move(some_int))</code> (i.e. with <code>int&&</code>, an xvalue) should be indistinguishable. We only care if it&rsquo;s an rvalue of one sort or another.</p>
<p>There are four invalid ("-") combinations. In all these cases <code>T</code> deduces to <code>int</code> (we can confirm by looking at error messages), it&rsquo;s just you can&rsquo;t actually call them:</p>
<ul>
<li><code>f(T& x)</code> with <code>int</code>. So e.g. we can&rsquo;t call <code>f(function_returning_3())</code>. This is because C++ <a href=https://en.cppreference.com/w/cpp/language/lifetime#Temporary_object_lifetime>won&rsquo;t extend the lifetime</a> of the resulting temporary - it only does that for a const lvalue reference (i.e. <code>f(const T&)</code>) or to an rvalue reference (<code>f(const T&&)</code> or <code>f(T&&)</code>). If this were allowed, and it extended the lifetime of the temporary, it would make it too easy to write code that appears to be modifying a variable passed by reference, but is actually only modifying a temporary.</li>
<li><code>f(T& x)</code> with <code>int&&</code>. In this case there&rsquo;s no need to extend a temporary - our <code>int</code> isn&rsquo;t going anywhere. But it&rsquo;s disallowed anyway, presumably for consistency between <code>int</code> and <code>int&&</code> as discussed above.</li>
<li><code>f(const T&& x)</code> with <code>int&</code>. This is an interesting one. Our <code>f</code> in this case does <em>not</em> take a forwarding reference. The <code>const</code> inhibits the special behaviour, so this is back to normal template argument deduction. <code>T</code> will never deduce as a reference - it&rsquo;s just plain <code>int</code> - so then we are just trying to call <code>f(int&&)</code> with an <code>int&</code>, which is obviously not allowed (if it were allowed, <code>f()</code> might move from something that it&rsquo;s not safe to move from).</li>
<li><code>f(const T&& x)</code> with <code>const int&</code>. Pretty much the same story as above, although because of the <code>const</code> it wouldn&rsquo;t actually be dangerous if it were allowed, just pointless and misleading.</li>
</ul>
<h1 id=summary>Summary</h1>
<p>In Part 1 we looked at getting type information dynamically with the <code>typeid</code> operator, which produces useful-ish output but is better suited to checking the dynamic type of objects at runtime. In Part 2 we used a trick involving an incomplete type to get the compiler to print the mystery type as an error message. In Part 3 we used variable templates to give strings to the types we were interested in, then produced a table of deduced template arguments when calling templated functions.</p>
</article>
<nav class="no-print post-nav">
<a class=prev-post href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_2/>
<img class=icon-text src=/img/prev.svg>Don't Take My Word For It (Part 2): Tricking the compiler</a>
</nav>
<script src=https://utteranc.es/client.js repo=cdyson37/cdyson37.github.io issue-term=url label=utterance theme=github-light crossorigin=anonymous async></script>
<hr class=sep>
</main>
<footer class="container no-print">
<div class=u-footer>
<a href=mailto:charlie@charliedyson.net><img class=icon-social src=/img/email.svg alt="Email Me!"></a>
<a href=https://github.com/cdyson37><img class=icon-social src=/img/github.svg alt=Github></a>
<a href=https://www.linkedin.com/in/charlie-dyson-a701a31a5><svg width="30" height="30" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg"><path d="M1e2.0C45 0 0 45 0 1e2V9e2c0 55 45 1e2 1e2 1e2H9e2c55 0 1e2-45 1e2-1e2V1e2C1e3 45 955 0 9e2.0H1e2s0 0 0 0m0 75s8e2.0 8e2.0c14 0 25 11 25 25V9e2c0 14-11 25-25 25H1e2c-14 0-25-11-25-25V1e2c0-14 11-25 25-25M336 332s0 457 0 457-125 0-125 0 0-457 0-457 125 0 125 0m10-126s0 0 0 0c0 41-33 74-73 74s-72-33-72-74c0-40 32-73 72-73s73 33 73 73M834 508s0 281 0 281-125 0-125 0 0-233 0-233c0-140-166-129-166 0V789s-124 0-124 0 0-457 0-457 124 0 124 0 0 74 0 74c58-108 291-116 291 102"/></svg></a>
<a href=https://charliedyson.net/index.xml target=_blank><img class=icon-social src=/img/feed.svg alt=Feed></a>
<p>
Theme used: <a href=https://github.com/yursan9/manis-hugo-theme>Manis</a><br>
</p>
<a href=#brand>
<img class=icon-text src=/img/toup.svg alt="To Up">
<span>Back to Up</span>
</a>
</div>
</footer>
</body>
</html>