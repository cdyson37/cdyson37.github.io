<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=generator content="Hugo 0.88.1">
<title>Don't Take My Word For It (Part 2): Tricking the compiler - charliedyson.net</title>
<meta name=description content="Using compiler error messages to accurately determine a type.">
<link rel=stylesheet href=/css/ui.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">
</head>
<body>
<header class="container no-print">
<div class=u-header>
<nav class=bar>
<ul><li>
<a href=/>
<img class=icon-text src=/img/prev.svg>
</a>
</li></ul>
</nav>
</div>
</header>
<main class=container>
<article>
<header><hgroup id=brand>
<h1>Don't Take My Word For It (Part 2): Tricking the compiler</h1>
<h5>
<time datetime="2021-12-26 00:00:00 +0000 UTC">26 Dec 2021</time>
<span class=no-print>
<span>
</h5>
</hgroup>
<hr class=sep>
</header>
<p>So far in <a href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_1/>Part 1</a> we&rsquo;ve covered:</p>
<ul>
<li>using <code>typeid</code> to get the type of a variable, subject to a friendly compiler vendor and losing the top-level const if there is one, and</li>
<li>using <code>typeid</code> to get the dynamic type of something.</li>
</ul>
<p>The first is useful in a pinch, but not portable, and the second sort of solves a different problem. In the &ldquo;pinch&rdquo; situation, we probably just want to know what <code>T</code> is and then get one with something else. The compiler generally knows what <code>T</code> is - perhaps we can trick it into telling us? Make it do something unreasonable with our mystery type <code>T</code> and hopefully the true identity of <code>T</code> will appear somewhere in the resulting error message(s).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;typeinfo&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> cpp_string <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>string (<span style=color:#e6db74>&#34;foo&#34;</span>);

  <span style=color:#75715e>// Try to get the type of cpp_string
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> cpp_string;
}
</code></pre></div><p>Compiler output on gcc (<a href=https://godbolt.org/z/MPYjTWva7>compiler explorer</a>):</p>
<pre tabindex=0><code>&lt;source&gt;: In function 'int main()':
&lt;source&gt;:9:11: error: cannot convert 'const std::__cxx11::basic_string&lt;char&gt;' to 'int' in initialization
    9 |   int i = cpp_string;
      |           ^~~~~~~~~~
      |           |
      |           const std::__cxx11::basic_string&lt;char&gt;```
</code></pre><p>Similarly with <code>const auto c_string = "foo"</code> we get <code>error: invalid conversion from 'const char*' to 'int'</code>. Note the slightly different error messages: evidently the compiler thinks quite differently about built-in conversions (in our case pointer-to-char and int) than it thinks about user-defined conversions (yes <code>std::string</code> from a <code>char*</code> counts as user-defined, even though <code>std::string</code> is in the standard library). In particular, we have again lost a <code>const</code> in this second message. We also run the risk of the the compiler helpfully listing all the <code>operator=</code>s it knows about and spamming the console.</p>
<p>There is a more reliable trick. We know <code>decltype()</code> can get the type of a variable or of an expression, but we need to get that type into an error message. Before, we took a value and did something unreasonable with it, now we want to take a type and do something unreasonable with it. Want to do something unreasonable with types? Use a template :).</p>
<p>First bit:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Incomplete</span>;
</code></pre></div><p><code>Incomplete</code> is a template struct that&rsquo;s incomplete - i.e. it&rsquo;s been declared (the compiler knows it exists) but not defined. There&rsquo;s no <code>{}</code> next to it, an object of <code>Incomplete&lt;int></code> could never exist because the compiler wouldn&rsquo;t even know how much space one needs.</p>
<p>In the hope that the compiler will give us a particularly readable error message, we now need to put this into action:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Incomplete</span>;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> c_string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foo&#34;</span>;

  <span style=color:#66d9ef>using</span> T <span style=color:#f92672>=</span> <span style=color:#66d9ef>decltype</span> (c_string);
  Incomplete<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> incomplete;
}
</code></pre></div><p>And by C++ standards it&rsquo;s not too bad (<a href=https://godbolt.org/z/5Kf5ohd55>compiler explorer</a>):</p>
<pre tabindex=0><code>&lt;source&gt;: In function 'int main()':
&lt;source&gt;:9:17: error: aggregate 'Incomplete&lt;const char* const&gt; incomplete' has incomplete type and cannot be defined
    9 |   Incomplete&lt;T&gt; incomplete;
      |                 ^~~~~~~~~~
</code></pre><p>The key bit is <code>Incomplete&lt;const char* const> incomplete</code>. The bit in the angle brackets is our mystery <code>T</code>, the type of <code>c_string</code>. A second <code>const</code> has appeared, because this is a const-pointer-to-a-const-char. In other words, you can&rsquo;t change the pointer (the memory address) and you can&rsquo;t change what it points to (the letter <code>f</code> as it happens).</p>
<p>For maximum unfriendliness and minimal typing, we can reduce this down slightly, using more letters and fewer words and typedefs:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>X</span>;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> ()
{
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> c_string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foo&#34;</span>;
  X<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(c_string)<span style=color:#f92672>&gt;</span> _;
}
</code></pre></div><p>Because why wouldn&rsquo;t you call your useless struct <code>X</code> and your impossible variable <code>_</code>? :) We also don&rsquo;t need <code>typename T</code> since we never use the <code>T</code>, so plain <code>typename</code> will do.</p>
<p>In this part of the series, we&rsquo;ve looked at the using error messages to deduce types. In <a href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_3/>Part 3</a> we will try to answer a general question about type deduction by generating a fancy table.</p>
</article>
<nav class="no-print post-nav">
<a class=prev-post href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_1/>
<img class=icon-text src=/img/prev.svg>Don't Take My Word For It (Part 1): Getting the type dynamically</a>
<a class=next-post href=https://charliedyson.net/blog/2021/12/dont_take_my_word_for_it_3/>Don't Take My Word For It (Part 3): A handy reference table<img class=icon-text src=/img/next.svg>
</a>
</nav>
<script src=https://utteranc.es/client.js repo=cdyson37/cdyson37.github.io issue-term=url label=utterance theme=github-light crossorigin=anonymous async></script>
<hr class=sep>
</main>
<footer class="container no-print">
<div class=u-footer>
<a href=mailto:charlie@charliedyson.net><img class=icon-social src=/img/email.svg alt="Email Me!"></a>
<a href=https://github.com/cdyson37><img class=icon-social src=/img/github.svg alt=Github></a>
<a href=https://www.linkedin.com/in/charlie-dyson-a701a31a5><svg width="30" height="30" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg"><path d="M1e2.0C45 0 0 45 0 1e2V9e2c0 55 45 1e2 1e2 1e2H9e2c55 0 1e2-45 1e2-1e2V1e2C1e3 45 955 0 9e2.0H1e2s0 0 0 0m0 75s8e2.0 8e2.0c14 0 25 11 25 25V9e2c0 14-11 25-25 25H1e2c-14 0-25-11-25-25V1e2c0-14 11-25 25-25M336 332s0 457 0 457-125 0-125 0 0-457 0-457 125 0 125 0m10-126s0 0 0 0c0 41-33 74-73 74s-72-33-72-74c0-40 32-73 72-73s73 33 73 73M834 508s0 281 0 281-125 0-125 0 0-233 0-233c0-140-166-129-166 0V789s-124 0-124 0 0-457 0-457 124 0 124 0 0 74 0 74c58-108 291-116 291 102"/></svg></a>
<a href=https://charliedyson.net/index.xml target=_blank><img class=icon-social src=/img/feed.svg alt=Feed></a>
<p>
Theme used: <a href=https://github.com/yursan9/manis-hugo-theme>Manis</a><br>
</p>
<a href=#brand>
<img class=icon-text src=/img/toup.svg alt="To Up">
<span>Back to Up</span>
</a>
</div>
</footer>
</body>
</html>